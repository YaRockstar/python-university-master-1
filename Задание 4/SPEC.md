# Вариант 6. Учет и управление транспортной компанией

Разработайте программное обеспечение для **учета и управления транспортной компанией**.  
Программа должна предоставлять возможность **создания записей** о транспортных средствах, водителях, маршрутах, рейсах и
других данных.  
Также программа должна поддерживать выполнение различных операций с данными, таких как **добавление, редактирование,
удаление, поиск и анализ**.

---

## Основные требования к реализации

### 1. Абстрактный класс `Vehicle` (транспортное средство)

- Создайте абстрактный класс `Vehicle`, который будет являться базовым для всех типов транспортных средств.
- В классе определите:
    - Абстрактный метод `calculate_cost`, который должен быть реализован в каждом подклассе.
    - Общие атрибуты для всех транспортных средств:  
      `vehicle_id` (идентификатор), `model` (модель), `year` (год выпуска), `capacity` (вместимость), `status` (статус).
    - Метод `__str__`, возвращающий строковое представление объекта  
      *(например, «Транспортное средство: [model], Год выпуска: [year]»)*.
    - Методы сравнения (`__lt__`, `__gt__`) для сравнения транспортных средств по году выпуска или вместимости.
- Используйте **инкапсуляцию**: сделайте атрибуты приватными и предоставьте доступ к ним через геттеры и сеттеры с
  аннотациями типов.

---

### 2. Наследование

- Создайте подклассы для различных типов транспортных средств:
    - `Bus` (автобус): добавьте атрибут `route_number` (номер маршрута).
    - `Truck` (грузовик): добавьте атрибут `cargo_capacity` (грузоподъемность).
    - `Taxi` (такси): добавьте атрибут `license_plate` (номерной знак).
- В каждом подклассе переопределите метод `calculate_cost` для расчета стоимости эксплуатации в зависимости от типа
  транспортного средства.
- Переопределите метод `__str__` для вывода дополнительной информации  
  *(например, «Автобус: [model], Номер маршрута: [route_number]»)*.

---

### 3. Композиция и агрегация

- Создайте класс `Driver`, который будет содержать информацию о водителе:
    - Атрибуты: `name` (имя), `driver_id` (идентификатор водителя),  
      `license_type` (тип водительских прав), `assigned_vehicle` (закрепленное транспортное средство).
    - Методы:
        - `assign_vehicle` — закрепить транспортное средство;
        - `remove_vehicle` — открепить транспортное средство;
        - `get_assigned_vehicle` — получить закрепленное транспортное средство.
- Используйте **композицию**: добавьте атрибут `address` (адрес водителя) через отдельный класс `Address`.
- Используйте **агрегацию**: водитель может существовать без закрепленного транспортного средства, но транспортное
  средство может быть закреплено позже.

---

### 4. Интерфейсы для работы с транспортной компанией

- Создайте интерфейс `Trackable`, который определяет метод `track_location`.  
  Этот метод должен быть реализован для отслеживания текущего местоположения транспортного средства.
- Добавьте второй интерфейс `Reportable`, который определяет метод `generate_report`.  
  Этот метод должен быть реализован для генерации отчетов о рейсах  
  *(например, «Отчет по рейсу: [данные]»)*.

---

### 5. Миксины

- Создайте миксин `LoggingMixin`, который добавляет функциональность **логирования действий** с транспортными
  средствами.  
  Например, метод `log_action`, который записывает действия  
  *(например, «Транспортное средство [model] отправлено в рейс»)*.
- Создайте второй миксин `NotificationMixin`, который добавляет функциональность **отправки уведомлений**.  
  Например, метод `send_notification`, который отправляет уведомления  
  *(например, «Транспортное средство [model] требует технического обслуживания»)*.
- Используйте оба миксина в подклассах для демонстрации множественного наследования.

---

### 6. Метаклассы

- Реализуйте метакласс `VehicleMeta`, который автоматически регистрирует все подклассы `Vehicle` в реестре.  
  Это позволит **динамически создавать экземпляры транспортных средств** по имени типа.

---

### 7. Фабричные методы

- Создайте класс `VehicleFactory` с методом `create_vehicle`, который принимает тип транспортного средства  
  (например, `"bus"`, `"truck"`, `"taxi"`) и создает соответствующий экземпляр класса.
- Используйте этот метод для создания транспортных средств в программе.

---

### 8. Цепочка обязанностей (Chain of Responsibility)

- Реализуйте паттерн **«Цепочка обязанностей»** для обработки запросов на техническое обслуживание. Например:
    - Механик может одобрить обслуживание, если оно не требует больших затрат.
    - Руководитель отдела может одобрить обслуживание, если затраты средние.
    - Директор компании может одобрить любое обслуживание.
- Создайте цепочку обработчиков (`Mechanic`, `DepartmentHead`, `Director`), которая последовательно передает запросы
  между звеньями.

---

### 9. Шаблонный метод (Template Method)

- Реализуйте шаблонный метод для стандартизации процесса расчета стоимости эксплуатации.  
  Создайте базовый класс `CostCalculator` с методом `calculate_cost`, который определяет общую структуру расчета:
    1. Получение базовой стоимости эксплуатации;
    2. Применение дополнительных расходов;
    3. Возврат итоговой стоимости.
- Подклассы (`BusCostCalculator`, `TruckCostCalculator`) должны реализовывать конкретные шаги расчета.

---

### 10. Декоратор для проверки прав доступа

- Создайте декоратор `check_permissions`, который проверяет права доступа пользователя перед выполнением определенных
  действий  
  (например, назначение водителя или изменение статуса транспортного средства).  
  Если у пользователя нет прав, выбрасывайте исключение `PermissionDeniedError`.

---

### 11. Исключения

- Создайте пользовательские исключения для обработки ошибок:
    - `InvalidVehicleError` — если транспортное средство содержит некорректные данные;
    - `PermissionDeniedError` — если у пользователя нет прав доступа;
    - `DriverNotFoundError` — если водитель не найден.

---

### 12. Сериализация и десериализация

- Реализуйте возможность **сохранения и загрузки данных** о транспортных средствах и водителях в файл (например, в
  формате JSON).
- Добавьте методы:
    - `to_dict` — преобразование объекта в словарь;
    - `from_dict` — создание объекта из словаря.

---

### 13. Методы сравнения

- Реализуйте методы `__eq__`, `__lt__`, `__gt__` для сравнения транспортных средств по году выпуска, вместимости или
  другим критериям.

---

### 14. Логирование и документация

- Настройте систему логирования с использованием библиотеки `logging`.  
  Логи должны записываться **в файл и в консоль**.
- Добавьте `docstrings` для всех методов и классов.

---

## Пример использования программы

1. **Создание транспортных средств:**
    - Используйте `VehicleFactory` для создания транспортных средств разных типов.
    - Добавьте транспортные средства в парк с помощью метода `add_vehicle`.

2. **Управление данными:**
    - Редактируйте данные транспортных средств через сеттеры.
    - Удаляйте транспортные средства из парка с помощью метода `remove_vehicle`.

3. **Анализ данных:**
    - Получите список всех транспортных средств с помощью метода `get_all_vehicles`.
    - Найдите транспортные средства по модели с помощью метода `search_by_model`.

4. **Логирование и уведомления:**
    - Используйте миксины `LoggingMixin` и `NotificationMixin` для записи действий и отправки уведомлений.

5. **Обработка исключений:**
    - Обрабатывайте пользовательские исключения при попытке назначения водителя с некорректными данными или при
      отсутствии прав доступа.

---

## Заключение

Данная программа демонстрирует применение **объектно-ориентированного программирования**, включая:

- наследование, композицию и агрегацию;
- интерфейсы, миксины, метаклассы, фабричные методы;
- паттерны проектирования (*Цепочка обязанностей*, *Шаблонный метод*);
- обработку исключений, логирование и сериализацию данных.
